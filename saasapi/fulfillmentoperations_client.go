//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.1, generator: @autorest/go@4.0.0-preview.43)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package saasapi

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

type FulfillmentOperationsClient struct {
	pl runtime.Pipeline
}

// NewFulfillmentOperationsClient creates a new instance of FulfillmentOperationsClient with the specified values.
// pl - the pipeline used for sending requests and handling responses.
func NewFulfillmentOperationsClient(pl runtime.Pipeline) *FulfillmentOperationsClient {
	client := &FulfillmentOperationsClient{
		pl: pl,
	}
	return client
}

// ActivateSubscription - Use this call to activate a subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// options - FulfillmentOperationsClientActivateSubscriptionOptions contains the optional parameters for the FulfillmentOperationsClient.ActivateSubscription
// method.
func (client *FulfillmentOperationsClient) ActivateSubscription(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsClientActivateSubscriptionOptions) (FulfillmentOperationsClientActivateSubscriptionResponse, error) {
	req, err := client.activateSubscriptionCreateRequest(ctx, subscriptionID, body, options)
	if err != nil {
		return FulfillmentOperationsClientActivateSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return FulfillmentOperationsClientActivateSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FulfillmentOperationsClientActivateSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return FulfillmentOperationsClientActivateSubscriptionResponse{}, nil
}

// activateSubscriptionCreateRequest creates the ActivateSubscription request.
func (client *FulfillmentOperationsClient) activateSubscriptionCreateRequest(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsClientActivateSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}/activate"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// DeleteSubscription - Unsubscribe and delete the specified subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// options - FulfillmentOperationsClientDeleteSubscriptionOptions contains the optional parameters for the FulfillmentOperationsClient.DeleteSubscription
// method.
func (client *FulfillmentOperationsClient) DeleteSubscription(ctx context.Context, subscriptionID string, options *FulfillmentOperationsClientDeleteSubscriptionOptions) (FulfillmentOperationsClientDeleteSubscriptionResponse, error) {
	req, err := client.deleteSubscriptionCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return FulfillmentOperationsClientDeleteSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return FulfillmentOperationsClientDeleteSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return FulfillmentOperationsClientDeleteSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteSubscriptionHandleResponse(resp)
}

// deleteSubscriptionCreateRequest creates the DeleteSubscription request.
func (client *FulfillmentOperationsClient) deleteSubscriptionCreateRequest(ctx context.Context, subscriptionID string, options *FulfillmentOperationsClientDeleteSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	return req, nil
}

// deleteSubscriptionHandleResponse handles the DeleteSubscription response.
func (client *FulfillmentOperationsClient) deleteSubscriptionHandleResponse(resp *http.Response) (FulfillmentOperationsClientDeleteSubscriptionResponse, error) {
	result := FulfillmentOperationsClientDeleteSubscriptionResponse{}
	if val := resp.Header.Get("Operation-Location"); val != "" {
		result.OperationLocationURI = &val
	}
	return result, nil
}

// GetSubscription - Gets the specified SaaS subscription. Use this call to get license information and plan information.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// options - FulfillmentOperationsClientGetSubscriptionOptions contains the optional parameters for the FulfillmentOperationsClient.GetSubscription
// method.
func (client *FulfillmentOperationsClient) GetSubscription(ctx context.Context, subscriptionID string, options *FulfillmentOperationsClientGetSubscriptionOptions) (FulfillmentOperationsClientGetSubscriptionResponse, error) {
	req, err := client.getSubscriptionCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return FulfillmentOperationsClientGetSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return FulfillmentOperationsClientGetSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FulfillmentOperationsClientGetSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getSubscriptionHandleResponse(resp)
}

// getSubscriptionCreateRequest creates the GetSubscription request.
func (client *FulfillmentOperationsClient) getSubscriptionCreateRequest(ctx context.Context, subscriptionID string, options *FulfillmentOperationsClientGetSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getSubscriptionHandleResponse handles the GetSubscription response.
func (client *FulfillmentOperationsClient) getSubscriptionHandleResponse(resp *http.Response) (FulfillmentOperationsClientGetSubscriptionResponse, error) {
	result := FulfillmentOperationsClientGetSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Subscription); err != nil {
		return FulfillmentOperationsClientGetSubscriptionResponse{}, err
	}
	return result, nil
}

// ListAvailablePlans - Use this call to find out if there are any private or public offers for the current publisher.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// options - FulfillmentOperationsClientListAvailablePlansOptions contains the optional parameters for the FulfillmentOperationsClient.ListAvailablePlans
// method.
func (client *FulfillmentOperationsClient) ListAvailablePlans(ctx context.Context, subscriptionID string, options *FulfillmentOperationsClientListAvailablePlansOptions) (FulfillmentOperationsClientListAvailablePlansResponse, error) {
	req, err := client.listAvailablePlansCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return FulfillmentOperationsClientListAvailablePlansResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return FulfillmentOperationsClientListAvailablePlansResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FulfillmentOperationsClientListAvailablePlansResponse{}, runtime.NewResponseError(resp)
	}
	return client.listAvailablePlansHandleResponse(resp)
}

// listAvailablePlansCreateRequest creates the ListAvailablePlans request.
func (client *FulfillmentOperationsClient) listAvailablePlansCreateRequest(ctx context.Context, subscriptionID string, options *FulfillmentOperationsClientListAvailablePlansOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}/listAvailablePlans"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listAvailablePlansHandleResponse handles the ListAvailablePlans response.
func (client *FulfillmentOperationsClient) listAvailablePlansHandleResponse(resp *http.Response) (FulfillmentOperationsClientListAvailablePlansResponse, error) {
	result := FulfillmentOperationsClientListAvailablePlansResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SubscriptionPlans); err != nil {
		return FulfillmentOperationsClientListAvailablePlansResponse{}, err
	}
	return result, nil
}

// NewListSubscriptionsPager - Lists all the SaaS subscriptions for a publisher.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// options - FulfillmentOperationsClientListSubscriptionsOptions contains the optional parameters for the FulfillmentOperationsClient.ListSubscriptions
// method.
func (client *FulfillmentOperationsClient) NewListSubscriptionsPager(options *FulfillmentOperationsClientListSubscriptionsOptions) (*runtime.Pager[FulfillmentOperationsClientListSubscriptionsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[FulfillmentOperationsClientListSubscriptionsResponse]{
		More: func(page FulfillmentOperationsClientListSubscriptionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *FulfillmentOperationsClientListSubscriptionsResponse) (FulfillmentOperationsClientListSubscriptionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listSubscriptionsCreateRequest(ctx, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return FulfillmentOperationsClientListSubscriptionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return FulfillmentOperationsClientListSubscriptionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return FulfillmentOperationsClientListSubscriptionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listSubscriptionsHandleResponse(resp)
		},
	})
}

// listSubscriptionsCreateRequest creates the ListSubscriptions request.
func (client *FulfillmentOperationsClient) listSubscriptionsCreateRequest(ctx context.Context, options *FulfillmentOperationsClientListSubscriptionsOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	if options != nil && options.ContinuationToken != nil {
		reqQP.Set("continuationToken", *options.ContinuationToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listSubscriptionsHandleResponse handles the ListSubscriptions response.
func (client *FulfillmentOperationsClient) listSubscriptionsHandleResponse(resp *http.Response) (FulfillmentOperationsClientListSubscriptionsResponse, error) {
	result := FulfillmentOperationsClientListSubscriptionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SubscriptionsResponse); err != nil {
		return FulfillmentOperationsClientListSubscriptionsResponse{}, err
	}
	return result, nil
}

// Resolve - The resolve endpoint enables the publisher to resolve a marketplace token to a persistent resource ID. The resource
// ID is the unique identifier for a SaaS subscription. When a user is redirected to a
// partner's website, the URL contains a token in the query parameters. The partner is expected to use this token and make
// a request to resolve it. The response contains the unique SaaS subscription ID,
// name, offer ID, and plan for the resource. This token is valid for one hour only.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// xmsMarketplaceToken - The token query parameter in the URL when the user is redirected to the SaaS partner's website from
// Azure (for example, https://contoso.com/signup?token=..). Note, The URL decodes the token value from
// the browser before using it.
// options - FulfillmentOperationsClientResolveOptions contains the optional parameters for the FulfillmentOperationsClient.Resolve
// method.
func (client *FulfillmentOperationsClient) Resolve(ctx context.Context, xmsMarketplaceToken string, options *FulfillmentOperationsClientResolveOptions) (FulfillmentOperationsClientResolveResponse, error) {
	req, err := client.resolveCreateRequest(ctx, xmsMarketplaceToken, options)
	if err != nil {
		return FulfillmentOperationsClientResolveResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return FulfillmentOperationsClientResolveResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return FulfillmentOperationsClientResolveResponse{}, runtime.NewResponseError(resp)
	}
	return client.resolveHandleResponse(resp)
}

// resolveCreateRequest creates the Resolve request.
func (client *FulfillmentOperationsClient) resolveCreateRequest(ctx context.Context, xmsMarketplaceToken string, options *FulfillmentOperationsClientResolveOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/resolve"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	req.Raw().Header["x-ms-marketplace-token"] = []string{xmsMarketplaceToken}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// resolveHandleResponse handles the Resolve response.
func (client *FulfillmentOperationsClient) resolveHandleResponse(resp *http.Response) (FulfillmentOperationsClientResolveResponse, error) {
	result := FulfillmentOperationsClientResolveResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ResolvedSubscription); err != nil {
		return FulfillmentOperationsClientResolveResponse{}, err
	}
	return result, nil
}

// UpdateSubscription - Use this call to update the plan, the user count (quantity), or both.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 2018-08-31
// options - FulfillmentOperationsClientUpdateSubscriptionOptions contains the optional parameters for the FulfillmentOperationsClient.UpdateSubscription
// method.
func (client *FulfillmentOperationsClient) UpdateSubscription(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsClientUpdateSubscriptionOptions) (FulfillmentOperationsClientUpdateSubscriptionResponse, error) {
	req, err := client.updateSubscriptionCreateRequest(ctx, subscriptionID, body, options)
	if err != nil {
		return FulfillmentOperationsClientUpdateSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return FulfillmentOperationsClientUpdateSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted) {
		return FulfillmentOperationsClientUpdateSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateSubscriptionHandleResponse(resp)
}

// updateSubscriptionCreateRequest creates the UpdateSubscription request.
func (client *FulfillmentOperationsClient) updateSubscriptionCreateRequest(ctx context.Context, subscriptionID string, body SubscriberPlan, options *FulfillmentOperationsClientUpdateSubscriptionOptions) (*policy.Request, error) {
	urlPath := "/saas/subscriptions/{subscriptionId}"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(	host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2018-08-31")
	req.Raw().URL.RawQuery = reqQP.Encode()
	if options != nil && options.RequestID != nil {
		req.Raw().Header["x-ms-requestid"] = []string{*options.RequestID}
	}
	if options != nil && options.CorrelationID != nil {
		req.Raw().Header["x-ms-correlationid"] = []string{*options.CorrelationID}
	}
	return req, runtime.MarshalAsJSON(req, body)
}

// updateSubscriptionHandleResponse handles the UpdateSubscription response.
func (client *FulfillmentOperationsClient) updateSubscriptionHandleResponse(resp *http.Response) (FulfillmentOperationsClientUpdateSubscriptionResponse, error) {
	result := FulfillmentOperationsClientUpdateSubscriptionResponse{}
	if val := resp.Header.Get("Operation-Location"); val != "" {
		result.OperationLocationURI = &val
	}
	return result, nil
}

